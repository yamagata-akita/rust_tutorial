スタック領域とヒープ領域

スタック領域
確保と開放→速い
領域の大きさ→小さい

ヒープ領域
確保と開放→遅い
領域の大きさ→大きい

スタック領域にはコンパイル時に大きさが決まっているデータが置かれる
データの大きさが変わるものはヒープ領域に入る

囲碁のデータを全部配列にして大きさを固定したら速度アップする？


v.push()
v.pop()
v.insert()
v.remove()

v.append()
v.extend_from_slice()


コレクション型
ベクタのような値の集合を格納する型の総称
・マップ: HasMap, BTreeMap
・セット: HashSet, BTreeSet
・キュー: VecDeque, BinaryHeap 
・リスト: LinkedList

HashMapやHashSetはキーをもとに生成されたハッシュ値によってデータの格納先が決定される。
暗号強度があり安全だが、ハッシュ化計算には時間がかかる。
暗号強度が必要ない場合は、FNVのようなハッシュアルゴリズムの仕様を検討すると良い。

リザルト型
Rustでは例外を投げるのではなく、リザルトのような値を返すことでエラーが起こったことを示す


構造体と列挙型について
・フィールドの可視性
・フィールドの可視性ドに参照をもたせる
・ジェネリクス
・内部表現とrepr(c)

・フィールドの可視性
デフォルトで非公開(private)
モジュール外からアクセスできるようにするにはpubキーワードを追加する
pub struct Polygon {
    pub vertexes: Vec<(i32, i32)>,
    pub stroke_width: u8,
    pub fill: (u8, u8, u8),
    internal_id: String,        // このフィールドだけはモジュール外からのアクセスが不可
}
構造体はフィールドごとの可視性を制御できるが、列挙型はできない

構造体や列挙型のフィールドに参照をもたせることもできる
その際はライフタイム指定子を明示しなければならない
// ライフタイム指定子('a)
struct StrRefs<'a> {
    s1: &'a str,
    s2: &'a str,
}



型強制が行われる場所
・let, static, const文
    let foo: U = e
      → eがU型へと型強制される

・関数の引数
    fn bar(x: U){}
      → bar(e)のように呼び出すとe型がU型へ型矯正される

・構造体やバリアントのフィールドへの値の設定
    struct Baz{x: U}
      → Baz{x: e}と初期化すると、eがU型へ型強制される

・ タプルリテラル
    let foo: (U, ..) = (e, ..)

・ 配列のリテラル
    let foo: [U; 10] = [e, ..]

・関数の戻り値
    fn bar() -> U {e}

・型推論により型が決まっている変数に別の値を再束縛するとき
  let mut i1 = 0u8;     // i1はu8型だと型推論される
  i1 = 255;             // 255はu8型へ型強制される