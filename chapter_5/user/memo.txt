スタック領域とヒープ領域

スタック領域
確保と開放→速い
領域の大きさ→小さい

ヒープ領域
確保と開放→遅い
領域の大きさ→大きい

スタック領域にはコンパイル時に大きさが決まっているデータが置かれる
データの大きさが変わるものはヒープ領域に入る

囲碁のデータを全部配列にして大きさを固定したら速度アップする？


v.push()
v.pop()
v.insert()
v.remove()

v.append()
v.extend_from_slice()


コレクション型
ベクタのような値の集合を格納する型の総称
・マップ: HasMap, BTreeMap
・セット: HashSet, BTreeSet
・キュー: VecDeque, BinaryHeap 
・リスト: LinkedList

HashMapやHashSetはキーをもとに生成されたハッシュ値によってデータの格納先が決定される。
暗号強度があり安全だが、ハッシュ化計算には時間がかかる。
暗号強度が必要ない場合は、FNVのようなハッシュアルゴリズムの仕様を検討すると良い。

リザルト型
Rustでは例外を投げるのではなく、リザルトのような値を返すことでエラーが起こったことを示す


構造体と列挙型について
・フィールドの可視性
・フィールドの可視性ドに参照をもたせる
・ジェネリクス
・内部表現とrepr(c)

・フィールドの可視性
デフォルトで非公開(private)
モジュール外からアクセスできるようにするにはpubキーワードを追加する
pub struct Polygon {
    pub vertexes: Vec<(i32, i32)>,
    pub stroke_width: u8,
    pub fill: (u8, u8, u8),
    internal_id: String,        // このフィールドだけはモジュール外からのアクセスが不可
}
構造体はフィールドごとの可視性を制御できるが、列挙型はできない

構造体や列挙型のフィールドに参照をもたせることもできる
その際はライフタイム指定子を明示しなければならない
// ライフタイム指定子('a)
struct StrRefs<'a> {
    s1: &'a str,
    s2: &'a str,
}