fn main() {
    // ユニット型(uint ytpe)
    // 空を表す型。値は空のタプル()で、ユニット値と呼ぶ。

    // 戻り値の型を省略。コンパイラは戻り値がユニット型だと解釈する
    /*
    fn hello() {
        println!("Hello");
    }
    */

    // 関数を呼び出し、戻り値に変数retを総縛する
    /*
    let ret = hello();
    // アサーションでretの値がユニット値と等しいことを検査する
    assert_eq!(ret, ());
    */

    // size_of::<型>()は、その型の値がメモリ上で占める大きさをバイト数で返す
    // ユニット型の値(ユニット値)のサイズは0バイト
    /*
    assert_eq!(std::mem::size_of::<()>(), 0);

    // boolのサイズは1バイト
    assert_eq!(std::mem::size_of::<bool>(), 1);
    */

    // 固定精度の整数(サフィックスに型名を付与できる)
    // 整数リテラルには、読みやすさのために途中_を含めることができる
    // リテラル == 値
    /*
    let n1 = 10_000;     // i32型(32ビット符号付き整数) 整数リテラルのデフォルトの型
    let n2 = 0u8;        // u8型(サフィックスで型を指定)
    let n3 = -100_isize; // isize型(環境に依存してビット数が変わる)

    // プレフィックスで進数を指定できる
    let h1 = 0xff; // i32型, 16進数
    let o1 = 0o744; // i32型、8進数
    let b1 = 0b1010_0110_1110_1001; // i32型、2進数

    // 整数演算の桁溢れ
    let n1 = std::u8::MAX; // u8型の最大値は255_u8
    let n2 = 1_u8;
    // 答えは256だがu8型では表現できない(オーバーフロー)
    // let n3 = n1 + n2;
    // println!("{}", n3);


    let n1 = 200_u8;
    let n2 = 3_u8;

    // n1 * n2 = 600 (桁溢れ)を計算する

    // 検査付き乗算 → Noneになる
    assert_eq!(n1.checked_mul(n2), None);

    // 飽和乗算 → u8の最大値255に張り付く
    assert_eq!(n1.saturating_mul(n2), std::u8::MAX);

    // ラッピング乗算 → 600を256で割ったあまりの88になる
    assert_eq!(n1.wrapping_mul(n2), 88);

    // 桁あふれ乗算 → 88と桁溢れを示すtrueのペアを返す
    assert_eq!(n1.overflowing_mul(n2), (88, true));
    */

    // 固定精度の浮動小数点数
    /*
    // let f1 = 10.0;        // f64型(小数リテラルのデフォルトの型)
    // let f2 = -1234.56f32; // f32型(サフィックスで型を指定)
    // let f3 = 478.6E+77;   // f64型(指数部も指定できる)
    */




    // 文字型
    /*
    let c1 = 'A'; // char型
    let c2 = 'a';
    assert!(c1 < c2); // 文字コード順で大小比較
    assert!(c1.is_uppercase()); // 大文字か検査

    // char型は1文字を表すのに、英数字であっても4バイト使う
    assert_eq!(std::mem::size_of::<char>(), 4);

    let c10 = '\u{5b57}'; // '字'をユニコードのエスケープコードで表現
    let c11 = '\u{1f600}'; // 絵文字

    println!("{}", c10);
    println!("{}", c11);
    */


    // 参照型(reference type)
    // メモリ安全なポインタ
    // ポインタはデータが格納されている場所を示す。(メモリのアドレス(番地))
    // usizeと同じビット幅の整数で表される

    /*
    // 関数f1は呼び出し元の値のコピーを引数nに束縛し、1に変更する
    fn f1(mut n: u32) {
        n = 1;
        println!("f1: n = {}", n);
    }

    // 関数f2は呼び出し元の値を示すポインタを受け取り、ポインタが指す
    // 場所に2を格納する
    fn f2(n_ptr: &mut u32) {
        println!("f2: n_ptr = {:p}", n_ptr);

        // *をつけると参照先にアクセスできる。これを参照外し(dereference)と呼ぶ
        *n_ptr = 2;
        println!("f2: *n_ptr = {}", *n_ptr);
    }

    let mut n = 0;
    println!("main: n = {}", n);
    f1(n);
    println!("main: n = {}", n);

    // '&mut n'でnの値を指す可変のポインタを作成する
    f2(&mut n);
    println!("main: n = {}", n);


    // イミュータブルな参照は、参照先の値の読み出しだけが可能
    // ミュータブルな参照は、参照先の値の読み出しと書き込みの両方が可能
    // 所有権システムでは、参照のことを借用とも呼ぶ。
    let c1 = 'A'; // char型
    let c1_ptr = &c1; // &char型。イミュータブルな参照(不変の参照)
    assert_eq!(*c1_ptr, 'A');

    let mut n1 = 0; // i32型
    let n1_ptr = &mut n1; // &mut i32型。ミュータブルな参照(可変の参照)
    assert_eq!(*n1_ptr, 0);

    // 可変の参照では参照先の値を変更できる
    *n1_ptr = 1_000;
    assert_eq!(*n1_ptr, 1_000);
    */


    // 生ポインタ型
    // メモリ安全ではないポインタ。
    // 不変の生ポインタは*const T型、可変の生ポインタは*mut T型
    /*
    let c1 = 'A';
    // &で参照を作り、型強制で生ポインタに変換する
    let c1_ptr: *const char = &c1; // *const char型。不変の生ポインタ
    // 生ポインタの参照外しはunsafeな操作
    assert_eq!(unsafe { *c1_ptr }, 'A');

    let mut n1 = 0;
    let n1_ptr: *mut i32 = &mut n1; // *mut i32型。可変の生ポインタ
    assert_eq!(unsafe { *n1_ptr }, 0);
    
    // 可変の生ポインタでは参照先の値を変更できる
    unsafe {
        *n1_ptr = 1_000;
        assert_eq!(*n1_ptr, 1_000);
    }

    // 生ポインタはポインタを他の言語との間で受け渡したり、所有権システムの管理から外したいときなどに使う。
    // コンパイラは以下の操作の安全性を保証しない。
    // そのためそれらについてはunsafeブロック内に書く必要がある。
    // ・参照外し
    // ・他のポインタ型への変換
    */


    // 関数ポインタ
    // 関数を示すポインタ
    // fn double(n: i32) ->i32
    // を指す関数ポインタはfn(i32) -> i32と表記する

    fn double(n: i32) -> i32 {
        n + n
    }

    fn abs(n: i32) -> i32 {
        if n>= 0 { n } else { -n }
    }

    // 変数に型注釈として関数ポインタ型を指定することで、関数名から関数ポインタを得られる
    let mut f: fn(i32) -> i32 = double;
    assert_eq!(f(-42), -84);

    f = abs;
    assert_eq!(f(-42), 42);

}
