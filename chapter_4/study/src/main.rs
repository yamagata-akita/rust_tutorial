fn main() {
    // ユニット型(uint ytpe)
    // 空を表す型。値は空のタプル()で、ユニット値と呼ぶ。

    // 戻り値の型を省略。コンパイラは戻り値がユニット型だと解釈する
    fn hello() {
        println!("Hello");
    }

    // 関数を呼び出し、戻り値に変数retを総縛する
    let ret = hello();
    // アサーションでretの値がユニット値と等しいことを検査する
    assert_eq!(ret, ());

    // size_of::<型>()は、その型の値がメモリ上で占める大きさをバイト数で返す
    // ユニット型の値(ユニット値)のサイズは0バイト
    assert_eq!(std::mem::size_of::<()>(), 0);

    // boolのサイズは1バイト
    assert_eq!(std::mem::size_of::<bool>(), 1);

    // 固定精度の整数(サフィックスに型名を付与できる)
    // 整数リテラルには、読みやすさのために途中_を含めることができる
    // リテラル == 値
    let n1 = 10_000;     // i32型(32ビット符号付き整数) 整数リテラルのデフォルトの型
    let n2 = 0u8;        // u8型(サフィックスで型を指定)
    let n3 = -100_isize; // isize型(環境に依存してビット数が変わる)

    // プレフィックスで進数を指定できる
    let h1 = 0xff; // i32型, 16進数
    let o1 = 0o744; // i32型、8進数
    let b1 = 0b1010_0110_1110_1001; // i32型、2進数

    // 整数演算の桁溢れ
    let n1 = std::u8::MAX; // u8型の最大値は255_u8
    let n2 = 1_u8;
    // 答えは256だがu8型では表現できない(オーバーフロー)
    // let n3 = n1 + n2;
    // println!("{}", n3);


    let n1 = 200_u8;
    let n2 = 3_u8;

    // n1 * n2 = 600 (桁溢れ)を計算する

    // 検査付き乗算 → Noneになる
    assert_eq!(n1.checked_mul(n2), None);

    // 飽和乗算 → u8の最大値255に張り付く
    assert_eq!(n1.saturating_mul(n2), std::u8::MAX);

    // ラッピング乗算 → 600を256で割ったあまりの88になる
    assert_eq!(n1.wrapping_mul(n2), 88);

    // 桁あふれ乗算 → 88と桁溢れを示すtrueのペアを返す
    assert_eq!(n1.overflowing_mul(n2), (88, true));


    // 固定精度の浮動小数点数

    let f1 = 10.0;        // f64型(小数リテラルのデフォルトの型)
    let f2 = -1234.56f32; // f32型(サフィックスで型を指定)
    let f3 = 478.6E+77;   // f64型(指数部も指定できる)
}
